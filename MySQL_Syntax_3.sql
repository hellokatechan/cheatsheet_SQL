--
-- MySQL_Syntax_3
--

--  ------------------------------------------------------------------

-- Review of JOINs, INDEXES, Temporary tables, and Views 

DROP DATABASE IF EXISTS baba;
CREATE DATABASE baba;
USE baba;

DROP TABLE IF EXISTS baba1;
CREATE TABLE baba1 (a INT, b TEXT, c FLOAT) engine = Innodb DEFAULT CHARSET = utf8; 
INSERT INTO baba1 VALUES(1, 'baba', 2.7);
INSERT INTO baba1 VALUES(2, 'mama', 3.1);
INSERT INTO baba1 VALUES(3, 'papa', 2.4);
INSERT INTO baba1 VALUES(4, 'haha', 3.7);
INSERT INTO baba1 VALUES(5, 'lala', 2.9);
INSERT INTO baba1 VALUES(6, 'tata', 3.1);
INSERT INTO baba1 VALUES(7, 'riba', 3.7);
INSERT INTO baba1 VALUES(8, 'beta', 2.7);

SELECT * FROM baba1;
DESCRIBE baba1;

SHOW INDEXES FROM baba1;
-- No indxes is observed. 

-- try again:
DROP TABLE IF EXISTS baba1;
CREATE TABLE baba1 (a INT, b TEXT, c FLOAT, INDEX(a)) engine = Innodb DEFAULT CHARSET = utf8; 
INSERT INTO baba1 VALUES(1, 'baba', 2.7);
INSERT INTO baba1 VALUES(2, 'mama', 3.1);
INSERT INTO baba1 VALUES(3, 'papa', 2.4);
INSERT INTO baba1 VALUES(4, 'haha', 3.7);
INSERT INTO baba1 VALUES(5, 'lala', 2.9);
INSERT INTO baba1 VALUES(6, 'tata', 3.1);
INSERT INTO baba1 VALUES(7, 'abba', 3.7);
INSERT INTO baba1 VALUES(8, 'beta', 2.7);

SHOW INDEXES FROM baba1;
 

-- Multiple Indexes & Assigning Names to them (useful when removing indexes)
DROP TABLE IF EXISTS baba1;
CREATE TABLE baba1 (a INT, b TEXT, c INT, INDEX myindex (a , c)) engine = Innodb DEFAULT CHARSET = utf8; 
INSERT INTO baba1 VALUES(1, 'baba', 27);
INSERT INTO baba1 VALUES(2, 'mama', 31);
INSERT INTO baba1 VALUES(3, 'papa', 24);
INSERT INTO baba1 VALUES(4, 'haha', 37);
INSERT INTO baba1 VALUES(5, 'lala', 29);
INSERT INTO baba1 VALUES(6, 'tata', 31);
INSERT INTO baba1 VALUES(7, 'abba', 37);
INSERT INTO baba1 VALUES(8, 'beta', 27);

SHOW INDEXES FROM baba1;
 
-- Removing Indexes
DROP INDEX myindex ON baba1;
SHOW INDEXES FROM baba1;
SHOW INDEX FROM baba1;

--
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 

-- Part 10: Controling the Columns by using Constraints:
-- Constraints create rules governing the behaviors of columns in a table
-- 
-- Assigning NOT NULL and UNIQUE constraints to columns
DROP TABLE IF EXISTS baba1;
CREATE TABLE baba1 (
  a INT UNIQUE, 
  b INT NOT NULL DEFAULT 0, 
  c TEXT,
  d INT NOT NULL DEFAULT 1, 
  INDEX myindex (a , b)) engine = Innodb DEFAULT CHARSET = utf8; 
INSERT INTO baba1 VALUES(1, 12, 'baba', 27);
INSERT INTO baba1 VALUES(2, 11, 'mama', 31);
INSERT INTO baba1 VALUES(3, 8, 'papa', 24);
INSERT INTO baba1 VALUES(4, 16, 'haha', 37);
INSERT INTO baba1 VALUES(5, 12, 'lala', 29);
INSERT INTO baba1 VALUES(6, 15, 'tata', 31);
INSERT INTO baba1 VALUES(7, 10, 'abba', 37);
INSERT INTO baba1 VALUES(8, 11, 'beta', 27);

SHOW INDEXES FROM baba1;
SHOW INDEX FROM baba1;
DESCRIBE baba1;

---
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 

-- Part 11: Creating an ID column:
-- An ID column is a column that is used as a unique identifier for each row in the table
-- An ID column is mostly used in relational databases to connect one table to another table
-- Assigning PRIMARY KEY will assign both NOT NULL and UNIQUE constraints, plus an INDEX

-- Note: If AUTO_INCREMENT is added to the definition of a column, then its values
--  will be automatically generated, and there will be no need to insert them look at
-- how there are only three values, i.e. 12, baba , 27. instead of four values because 
-- the id column is auto generated by the auto_increment function 

DROP TABLE IF EXISTS baba1;
CREATE TABLE baba1 (
  id INT AUTO_INCREMENT PRIMARY KEY, 
  b INT NOT NULL DEFAULT 0, 
  c VARCHAR(255),
  d INT NOT NULL DEFAULT 1, 
  INDEX myindex (b)) engine = Innodb DEFAULT CHARSET = utf8; 
INSERT INTO baba1 (b, c, d) VALUES(12, 'baba', 27);
INSERT INTO baba1 (b, c, d) VALUES(11, 'mama', 31);
INSERT INTO baba1 (b, c, d) VALUES(8, 'papa', 24);
INSERT INTO baba1 (b, c, d) VALUES(16, 'haha', 37);
INSERT INTO baba1 (b, c, d) VALUES(12, 'lala', 29);
INSERT INTO baba1 (b, c, d) VALUES(15, 'tata', 31);
INSERT INTO baba1 (b, c, d) VALUES(10, 'abba', 37);
INSERT INTO baba1 (b, c, d) VALUES(11, 'beta', 27);

SELECT * FROM baba1;
SHOW INDEXES FROM baba1;
DESCRIBE baba1;
SELECT last_insert_id();

-- Note: In MySQL, the constraint SERIAL can be used for a primary key.
-- SERIAL = BIGINT + Unsigned + AUTO_INCREMENT + UNIQUE + NOT NULL + PRIMARY KEY


--
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 


-- Part 12: Using foreign key constraints
-- 
DROP DATABASE IF EXISTS library2;
CREATE DATABASE library2;
USE library2;

CREATE TABLE Members (
  id INT AUTO_INCREMENT PRIMARY KEY, 
  Name TEXT NOT NULL,
  MembershipYears INT NOT NULL DEFAULT 0, 
  Age INT NOT NULL DEFAULT 1, 
  INDEX myindex (MembershipYears)) engine = Innodb DEFAULT CHARSET = utf8; 
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Ken',10, 27);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Zack', 11, 26);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Ivo', 4, 31);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Zeus', 12, 26);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Valerie', 11, 27);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Alex', 12, 26);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Saurabh', 8, 27);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Patrick', 6, 27);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Lily', 6, 26);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Meili', 8, 27);
INSERT INTO Members (Name, MembershipYears, Age) VALUES('Russell', 5, 108);

SELECT * FROM Members;

CREATE TABLE Books (
  id INT AUTO_INCREMENT PRIMARY KEY, 
  Title TEXT NOT NULL
) engine = Innodb DEFAULT CHARSET = utf8; 

INSERT INTO Books (Title) VALUES('Gone with the Wind');
INSERT INTO Books (Title) VALUES('Diary of a Wimpy Kid');
INSERT INTO Books (Title) VALUES('Let Trump be Trump');
INSERT INTO Books (Title) VALUES('Giraffes Cannot Dance');
INSERT INTO Books (Title) VALUES('Natural Disaster');
INSERT INTO Books (Title) VALUES('Humans of New York');
INSERT INTO Books (Title) VALUES('Wonder');
INSERT INTO Books (Title) VALUES('Auggie & Me');
INSERT INTO Books (Title) VALUES('Milk & Vine');

SELECT * FROM Books;

CREATE TABLE Records (
  id INT AUTO_INCREMENT PRIMARY KEY, 
  stamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  Member_id INT,
  Book_id INT
);
INSERT INTO Records (member_id,Book_id) VALUES(1,1);
INSERT INTO Records (member_id,Book_id) VALUES(9,2);
INSERT INTO Records (member_id,Book_id) VALUES(2,5);
INSERT INTO Records (member_id,Book_id) VALUES(3,8);
INSERT INTO Records (member_id,Book_id) VALUES(4,9);
INSERT INTO Records (member_id,Book_id) VALUES(10,3);
INSERT INTO Records (member_id,Book_id) VALUES(6,4);
INSERT INTO Records (member_id,Book_id) VALUES(5,6);

SELECT * FROM Records;

DROP TABLE IF EXISTS Records;
CREATE TABLE Records (
  id INT AUTO_INCREMENT PRIMARY KEY,
  stamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
  Member_id INT,
  Book_id INT,
  FOREIGN KEY (Member_id) REFERENCES Members(id),
  FOREIGN KEY (Book_id) REFERENCES Books(id)
);

INSERT INTO Records (member_id,Book_id) VALUES(1,1);
INSERT INTO Records (member_id,Book_id) VALUES(1,2);
INSERT INTO Records (member_id,Book_id) VALUES(2,5);
INSERT INTO Records (member_id,Book_id) VALUES(3,8);
INSERT INTO Records (member_id,Book_id) VALUES(4,9);
INSERT INTO Records (member_id,Book_id) VALUES(8,3);
INSERT INTO Records (member_id,Book_id) VALUES(6,4);
INSERT INTO Records (member_id,Book_id) VALUES(5,6);

SELECT * FROM Records;


-- Crerating a JOIN in order to know who has borrowed what book:
SELECT * FROM Records;
SELECT * FROM Members;
SELECT * FROM Books;


SELECT A.id, A.stamp, B.Title, C.Name
  FROM Records AS A
  LEFT JOIN Members AS C ON A.Member_id = C.id
  LEFT JOIN Books AS B ON A.Book_id = B.id;

-- Or, 
SELECT Records.id, Records.stamp, Books.Title, Members.Name
  FROM Records 
  LEFT JOIN Members ON Records.Member_id = Members.id
  LEFT JOIN Books ON Records.Book_id = Books.id;




--
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 

-- Part 13 - Altering Tables:
--
ALTER TABLE Records ADD DueDate TIMESTAMP;
SELECT * FROM Records;

ALTER TABLE Records DROP DueDate;
SELECT * FROM Records;

ALTER TABLE Records ADD DueDate TIMESTAMP NOT NULL DEFAULT 0;
SELECT * FROM Records;


-- To indicate a future due date, a TRIGGER should be created first (TRIGGERS later!)

-- 
INSERT INTO Records (Member_id, Book_id, DueDate) 
     VALUES(8, 7, DATE_ADD(NOW(), INTERVAL 30 DAY));
 
SELECT * FROM Records;


-- More on ALTER
ALTER TABLE Records DROP DueDate;

ALTER TABLE Records ADD DueDate TIMESTAMP NOT NULL DEFAULT 0 AFTER stamp;
SELECT * FROM Records;

ALTER TABLE Records ADD AlternativeDueDate TIMESTAMP NOT NULL DEFAULT now() AFTER Member_id;
SELECT * FROM Records;

ALTER TABLE Records ADD id2 INT FIRST;
SELECT * FROM Records;

ALTER TABLE Records DROP id2;

ALTER TABLE Records ADD id2 INT AFTER id;
SELECT * FROM Records;

ALTER TABLE Records DROP id2;



--
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 

-- Part 14 - Additional Examples of:
-- Distinct
-- AND , OR, NOT
-- ORDER BY
-- BETWEEN, NOT BETWEEN
-- GROUP BY
-- LIMIT
-- HAVING





-- Create database dataMedical2to line 546
DROP DATABASE IF EXISTS dataMedical2;
CREATE DATABASE IF NOT EXISTS dataMedical2;
USE dataMedical2;

-- Table structure for table `MedicalCenters`
--

DROP TABLE IF EXISTS `MedicalCenters`;
CREATE TABLE `MedicalCenters` (
  `ID` int(11) NOT NULL,
  `Nickname` varchar(30) DEFAULT NULL,
  `FullName` varchar(255) DEFAULT NULL,
  `Town` varchar(50) DEFAULT NULL,
  `State` char(2) DEFAULT NULL,
  `Zip` char(5) DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `MedicalCenters`
--

LOCK TABLES `MedicalCenters` WRITE;
INSERT INTO `MedicalCenters` VALUES (10,'River North','River North Medical Center','Cambridge','MA','02141'),(14,'River South','River South Medical Center','Boston','MA','02115');
UNLOCK TABLES;

SELECT * FROM MedicalCenters;

-- Table structure for table Plans:

DROP TABLE IF EXISTS `Plans`;
CREATE TABLE `Plans` (
  `ID` int(11) NOT NULL,
  `Tier` varchar(30) DEFAULT NULL,
  `MaxOutOfPocket` int(11) DEFAULT NULL,
  `HSA` varchar(2) DEFAULT NULL,
  PRIMARY KEY (`ID`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `Plans`
--

LOCK TABLES `Plans` WRITE;
INSERT INTO `Plans` VALUES (801,'Gold',0,'T'),(802,'Silver',3000,'T'),(803,'Bronze',6000,'F');
UNLOCK TABLES;

SELECT * FROM Plans;


-- Table structure for table `Buildings`
--

DROP TABLE IF EXISTS `Buildings`;
CREATE TABLE `Buildings` (
  `ID` int(11) NOT NULL,
  `Nickname` varchar(30) DEFAULT NULL,
  `FullName` varchar(255) DEFAULT NULL,
  `StreetNumber` int(11) DEFAULT NULL,
  `StreetName` varchar(45) DEFAULT NULL,
  `MedicalCenters_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Buildings_MedicalCenters1_idx` (`MedicalCenters_ID`),
  CONSTRAINT `MedicalCenters_ID` FOREIGN KEY (`MedicalCenters_ID`) REFERENCES `MedicalCenters` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

--
-- Dumping data for table `Buildings`
--

LOCK TABLES `Buildings` WRITE;
INSERT INTO `Buildings` VALUES (346,'Porter','Purple Porter Building',103,'Center Ave.',10),(352,'Davis','Blue Davis Building',105,'Center Ave.',10),(368,'Kendall','Red Kendall Building',100,'Main St.',10),(379,'Central','Green Central Building',200,'Main St.',10),(412,'Park','Yellow Park Building',613,'Broadway Ave.',14),(489,'Alewife','Orange Alewife Building',569,'Broadway Ave.',14);
UNLOCK TABLES;

SELECT * FROM Buildings;

-- Table structure for table `Departments`
--

DROP TABLE IF EXISTS `Departments`;
CREATE TABLE `Departments` (
  `ID` int(11) NOT NULL,
  `Name` varchar(80) DEFAULT NULL,
  `Type` varchar(45) DEFAULT NULL,
  `Status` varchar(30) DEFAULT NULL,
  `Floor` int(11) DEFAULT NULL,
  `Buildings_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Departments_Buildings1_idx` (`Buildings_ID`),
  CONSTRAINT `Buildings_ID` FOREIGN KEY (`Buildings_ID`) REFERENCES `Buildings` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `Departments`
--

LOCK TABLES `Departments` WRITE;
INSERT INTO `Departments` VALUES (1000,'Human Resources','Administrative','Active',2,352),(1010,'Payroll','Administrative','Active',3,352),(1040,'Finance','Administrative','Active',5,352),(2043,'Dermatology','Medical - Specialist','Active',5,489),(2123,'Pediatrics','Medical - General','Active',2,489),(2234,'Sports Medicine','Medical - Specialist','Defunct',1,379),(2345,'Psychiatry','Medical - Specialist','Active',2,412),(2353,'Internal Medicine','Medical - General','Active',2,368),(2439,'General Surgery','Medical - Specialist','Active',3,489),(2443,'Internal Medicine','Medical - General','Active',1,489),(2547,'Cardiology','Medical - Specialist','Active',4,368),(2548,'Gastroenterology','Medical - Specialist','Active',5,368),(2549,'Optometry','Medical - Specialist','Active',1,346),(2576,'Endocrinology','Medical - Specialist','Active',3,412),(2594,'Neurology','Medical - Specialist','Active',2,346);
UNLOCK TABLES;

SELECT * FROM Departments;


-- Table structure for table `Employees`
--

DROP TABLE IF EXISTS `Employees`;
CREATE TABLE `Employees` (
  `ID` int(11) NOT NULL,
  `FirstName` varchar(30) DEFAULT NULL,
  `LastName` varchar(45) DEFAULT NULL,
  `Title` varchar(45) DEFAULT NULL,
  `Status` varchar(45) DEFAULT NULL,
  `PhoneExt` int(11) DEFAULT NULL,
  `Email` varchar(45) DEFAULT NULL,
  `PrimaryDepts_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Employees_Departments1_idx` (`PrimaryDepts_ID`),
  CONSTRAINT `PrimaryDepts_ID` FOREIGN KEY (`PrimaryDepts_ID`) REFERENCES `Departments` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `Employees`
--

LOCK TABLES `Employees` WRITE;
INSERT INTO `Employees` VALUES (94000,'Bonnie','Lee','Doctor','Current',76222,'b.lee@datamed.com',2123),(94012,'Henry','Parker','Surgeon','Current',76843,'h.parker@datamed.com',2439),(94053,'Skyler','Honeypot','Physician Assistant','Current',76932,'s.honeypot@datamed.com',2443),(94068,'Kyle','Cook','Doctor','Current',76496,'k.cook@datamed.com',2443),(94094,'Polly','Wormwood','Doctor','Current',76044,'p.wormwood@datamed.com',2353),(94099,'Jonathan','Martinez','Doctor','Current',76053,'j.martinez@datamed.com',2548),(94122,'Courtney','Ford','Assistant Manager','Current',76843,'c.ford@datamed.com',1010),(94123,'Thomas','Anderson','Doctor','Current',76512,'t.ansderson@datamed.com',2548),(94126,'Teresa','Adams','Doctor','Current',76733,'t.adams@datamed.com',2576),(94165,'Linda','Marshall','Director','Current',76233,'l.marshall@datamed.com',1000),(94312,'Timothy','Brown','Assistant','Current',76223,'t.brown@datamed.com',1000),(94323,'Diana','West','Manager','Current',76433,'d.west@datamed.com',1010),(94324,'Eliza','Greenleaf','Vice President','Current',76323,'e.greenleaf@datamed.com',1040),(94329,'Dale','Thompson','Physician Assistant','Previous',76843,'d.thompson@datamed.com',2234),(94333,'Lindsey','Young','Registered Nurse','Current',76431,'l.young@datamed.com',2576),(94343,'Charles','Griffin','Assistant Director','Current',76432,'c.griffin@datamed.com',1040),(94434,'Andra','Cooper','Registered Nurse','Current',76025,'a.cooper@datamed.com',2547),(94435,'Nicholas','Stilton','Doctor','Current',76834,'n.stilton@datamed.com',2548),(94441,'Sylvia','Apple','Physician Assistant','Current',76777,'s.apple@datamed.com',2043),(94489,'Christopher','Rivera','Doctor','Current',76444,'c.rivera@datamed.com',2345),(94534,'Catherine','Sanders','Doctor','Previous',76943,'c.sanders@datamed.com',2548),(94545,'Julian','Rodriguez','Doctor','Previous',76143,'j.rodriguez@datamed.com',2234),(94546,'Teri','Watson','Doctor','Current',76230,'t.watson@datamed.com',2594),(94548,'Phillip','Hughes','Doctor','Current',76612,'p.hughes@datamed.com',2547),(94564,'Lorin','Graham','Registered Nurse','Current',76632,'l.graham@datamed.com',2353),(94759,'Juliana','Lewis','Surgeon','Current',76033,'j.lewis@datamed.com',2439),(94777,'Max','Rogers','Doctor','Current',76745,'m.rogers@datamed.com',2345),(94888,'Samantha','Biscuit','Doctor','Current',76322,'s.biscuit@datamed.com',2043),(94941,'Nicole','Fox','Registered Nurse','Current',76532,'n.fox@datamed.com',2594),(94959,'Lily','Sanchez','Doctor','Current',76434,'l.sanchez@datamed.com',2123);
UNLOCK TABLES;

--
SELECT * FROM Employees;

--
-- Table structure for table `Patients`
--

DROP TABLE IF EXISTS `Patients`;
CREATE TABLE `Patients` (
  `ID` int(11) NOT NULL,
  `FirstName` varchar(30) DEFAULT NULL,
  `LastName` varchar(45) DEFAULT NULL,
  `OutOfPocketToDate` double DEFAULT NULL,
  `Plans_ID` int(11) NOT NULL,
  `PCP_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Patients_Plans1_idx` (`Plans_ID`),
  KEY `fk_Patients_Employees1_idx` (`PCP_ID`),
  CONSTRAINT `PCP_ID` FOREIGN KEY (`PCP_ID`) REFERENCES `Employees` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `Plans_ID` FOREIGN KEY (`Plans_ID`) REFERENCES `Plans` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;


--
-- Dumping data for table `Patients`
--

LOCK TABLES `Patients` WRITE;
INSERT INTO `Patients` VALUES (6510,'William','Smith',0,801,94094),(6511,'Linda','Johnson',0,801,94053),(6512,'David','Williams',1100,802,94000),(6513,'Elizabeth','Jones',1500,802,94094),(6514,'Barbara','Brown',3000,802,94053),(6515,'John','Davis',5460,803,94000),(6516,'Patricia','Miller',0,803,94094),(6517,'Paul','Hollywood',100,803,94053),(6518,'James','Wilson',0,801,94000),(6519,'Jennifer','Moore',0,801,94094),(6520,'Robert','Taylor',1000,802,94094),(6521,'Mary','Berry',3250,803,94000),(6522,'Michael','Thomas',400,802,94094);
UNLOCK TABLES;

SELECT * FROM Patients;


-- Table structure for table `Appointments`
--

DROP TABLE IF EXISTS `Appointments`;
CREATE TABLE `Appointments` (
  `ID` int(11) NOT NULL,
  `TimeDate` datetime DEFAULT NULL,
  `TimeLength` int(11) DEFAULT NULL,
  `Room` varchar(10) DEFAULT NULL,
  `Cost` double DEFAULT NULL,
  `Copay` double DEFAULT NULL,
  `PrimaryEmployees_ID` int(11) NOT NULL,
  `Patients_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Appointments_Employees1_idx` (`PrimaryEmployees_ID`),
  KEY `fk_Appointments_Patients1_idx` (`Patients_ID`),
  CONSTRAINT `Patients_ID` FOREIGN KEY (`Patients_ID`) REFERENCES `Patients` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `PrimaryEmployees_ID` FOREIGN KEY (`PrimaryEmployees_ID`) REFERENCES `Employees` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `Appointments`
--

LOCK TABLES `Appointments` WRITE;
INSERT INTO `Appointments` VALUES (432010,'2017-06-15 09:30:00',30,'A',175,0,94545,6518),(432098,'2017-06-15 09:30:00',30,'G',675,0,94435,6511),(432111,'2017-06-15 09:30:00',50,'F',150,50,94099,6517),(432432,'2017-06-15 09:30:00',30,'A',350,0,94548,6510),(432456,'2017-06-15 09:30:00',50,'F',500,30,94329,6512),(432566,'2017-06-15 09:30:00',50,'D',500,50,94534,6513),(432656,'2017-06-15 09:30:00',50,'E',125,0,94434,6516),(432898,'2017-06-15 09:30:00',45,'A',600,100,94329,6515),(432989,'2017-06-15 09:30:00',45,'B',550,30,94546,6514);
UNLOCK TABLES;

SELECT * FROM Appointments;


--
-- Table structure for table `Notes`
--

DROP TABLE IF EXISTS `Notes`;
CREATE TABLE `Notes` (
  `ID` int(11) NOT NULL,
  `Text` text,
  `Appointments_ID` int(11) NOT NULL,
  `Employees_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Notes_Appointments1_idx` (`Appointments_ID`),
  KEY `fk_Notes_Employees1_idx` (`Employees_ID`),
  CONSTRAINT `Appointments_ID` FOREIGN KEY (`Appointments_ID`) REFERENCES `Appointments` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `Employees_ID` FOREIGN KEY (`Employees_ID`) REFERENCES `Employees` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `Notes`
--

LOCK TABLES `Notes` WRITE;
INSERT INTO `Notes` VALUES (5553245,'Patient has high blood pressure',432432,94548),(5553246,'Patient is worried about being lethargic',432098,94435),(5553247,'Patient has gained weight',432456,94329),(5553248,'Patient should return in one month',432566,94534);
UNLOCK TABLES;

SELECT * FROM Notes;
--

-- Table structure for table `Prescriptions`
--

DROP TABLE IF EXISTS `Prescriptions`;
CREATE TABLE `Prescriptions` (
  `ID` int(11) NOT NULL,
  `Cost` double DEFAULT NULL,
  `Copay` double DEFAULT NULL,
  `DrugName` varchar(255) DEFAULT NULL,
  `Count` double DEFAULT NULL,
  `Unit` varchar(10) DEFAULT NULL,
  `Strength` double DEFAULT NULL,
  `StrengthUnit` varchar(10) DEFAULT NULL,
  `Refills` int(11) DEFAULT NULL,
  `Patients_ID` int(11) NOT NULL,
  `Employees_ID` int(11) NOT NULL,
  PRIMARY KEY (`ID`),
  KEY `fk_Prescriptions_Patients1_idx` (`Patients_ID`),
  KEY `fk_Prescriptions_Employees1_idx` (`Employees_ID`),
  CONSTRAINT `Employees_ID2` FOREIGN KEY (`Employees_ID`) REFERENCES `Employees` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION,
  CONSTRAINT `Patients_ID2` FOREIGN KEY (`Patients_ID`) REFERENCES `Patients` (`ID`) ON DELETE NO ACTION ON UPDATE NO ACTION
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- Dumping data for table `Prescriptions`
--

LOCK TABLES `Prescriptions` WRITE;
INSERT INTO `Prescriptions` VALUES (1000001,140,10,'Drug A',90,'pills',500,'microgram',1,6515,94000),(1000002,50,5,'Drug B',5,'ounces',25,'milligram',0,6521,94000),(1000003,250,50,'Drug C',50,'pills',10,'milligram',1,6513,94094),(1000004,150,30,'Drug C',30,'pills',10,'milligram',3,6515,94000),(1000005,300,20,'Drug B',3,'ounces',150,'microgram',2,6521,94000);
UNLOCK TABLES;

-- Database Datamedical2 is now complete


SHOW DATABASES;

-- Concept: Display calculated fields from a table
-- Find out how much the insurance company is paying for each appointment, by appointment ID:

SELECT ID, Cost, Copay, (Cost - Copay) FROM Appointments;

-- Concept: Calculated fields as constraints using the WHERE clause
-- Find the very costly appointments for the insurance company (more than $500), by appointment ID 
SELECT ID, (Cost - Copay) AS InsuranceCost FROM Appointments WHERE (Cost - Copay) > 500;

-- Concept: Using SELECT with statistical functions
-- Find the prescriptions which cost at least  $100 to the insurance company, include the employee ID as well
SELECT ID, (Cost - Copay) AS InsuranceCost, Employees_ID 
FROM Prescriptions 
WHERE (Cost - Copay) >= 100;


-- How much is the average co-pay?
SELECT AVG(Copay) FROM Prescriptions;

-- Find the total cost of prescriptions to the insurance company for the provider 
--   with employee ID number 94000
SELECT SUM(Cost - Copay) FROM Prescriptions WHERE Employees_ID = 94000;

-- Select all of the attributes and records from the medical centers table
SELECT * FROM MedicalCenters;

-- Duplicate rows: query will get two instances of 'MA'
SELECT State FROM MedicalCenters;

-- Concept: The DISTINCT clause
-- Select, but eliminate duplicates: 
SELECT DISTINCT State FROM MedicalCenters;

-- Try selecting unique town AND state
-- FILL IT IN
SELECT DISTINCT Town, State FROM MedicalCenters;
SELECT DISTINCT State, Town FROM MedicalCenters;
SELECT DISTINCT Town AND State FROM MedicalCenters;

-- Concept: SELECT with statistical functions and constraint
SELECT Patients_ID, COUNT(*) FROM Prescriptions WHERE Patients_ID = 6515;

-- Count the number of prescriptions for each customer
-- not right
SELECT Patients_ID, COUNT(*) FROM Prescriptions;
-- not right either:
SELECT DISTINCT Patients_ID, COUNT(*) FROM Prescriptions;
-- this is ok
SELECT Patients_ID, COUNT(*) FROM Prescriptions 
GROUP BY Patients_ID;


-- Calculate the total bonus for each employee as 5% of the cost of each appointment, 
--   return by employee ID.
-- FILL IT IN
SHOW TABLES FROM dataMedical2;
SELECT * FROM dataMedical2.Appointments;

SELECT PrimaryEmployees_ID, (0.05*Cost) AS 'Bonus' 
FROM Appointments 
ORDER BY Bonus DESC;

--
-- Concept: Additional Constraints 

SELECT * FROM MedicalCenters WHERE Town='Boston';
SELECT * FROM MedicalCenters WHERE Town IN ('Boston' , 'Cambridge', 'Somerville');

-- Constrants using WHERE and logical connectives
SELECT * FROM MedicalCenters WHERE Town = 'Boston' OR Town = 'Cambridge' OR Town = 'Somerville';

-- Concept: Boolian WHERE with connective AND for applying constraints
-- Select rows where the column value is between two numbers:
-- Patients example:

SELECT * FROM Patients WHERE OutOfPocketToDate BETWEEN 3000 AND 5000;
-- [Note: Range is inclusive (>=50000 and <=100000)]
-- Alternative form:
SELECT * FROM Patients WHERE (OutOfPocketToDate >= 3000 AND OutOfPocketToDate <= 5000);
SELECT * FROM Patients WHERE NOT(OutOfPocketToDate < 3000 OR OutOfPocketToDate > 5000);

-- Select rows where the column value is outside a certain range:
SELECT * FROM Patients WHERE OutOfPocketToDate NOT BETWEEN 3000 AND 5000;
-- Alternative form:
SELECT * FROM Patients WHERE (OutOfPocketToDate < 3000 OR OutOfPocketToDate > 5000);

-- Concept Sorting by using the ORDER BY caluse
-- Note: By default ORDER BY is ASC
-- Order by one column (ASC or DESC)

SELECT * FROM Prescriptions ORDER BY Cost ASC;
SELECT * FROM Prescriptions ORDER BY Cost;
SELECT * FROM Prescriptions ORDER BY Cost DESC;

-- ORDER BY two columns, one first, and then the next:
SELECT * FROM Prescriptions ORDER BY DrugName ASC , Cost ASC;

-- Concept: The GROUP BY clause
-- List the total cost and average cost from each drug, order by the average cost, descending 
-- FILL IT IN
SELECT DrugName, SUM(Cost), AVG(Cost) FROM Prescriptions 
GROUP BY DrugName 
ORDER BY AVG(Cost) DESC;
-- Try without using the GROUP BY clause
SELECT DrugName, SUM(Cost), AVG(Cost) FROM Prescriptions ORDER BY AVG(Cost) DESC;

-- Concept: Using the LIMIT clause to restrict outputs
-- Restrict the number of output rows:
-- Find the most expensive drug by average cost:

SELECT DrugName, SUM(Cost), AVG(Cost) 
FROM Prescriptions 
GROUP BY DrugName 
ORDER BY AVG(Cost) DESC
LIMIT 2;

-- More SELECT + statistical functions:
-- Count the number of times each drug was prescribed

SELECT DrugName, COUNT(*) AS TimesPrescribed FROM Prescriptions GROUP BY DrugName;

-- Concept: Using HAVING to io  impose contraints:
-- List number of times each drug was prescribed for drugs which have been prescribed more than once
SELECT DrugName, COUNT(*) AS TimesPrescribed FROM Prescriptions GROUP BY DrugName
HAVING TimesPrescribed > 1;

--
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 
--  -- -- ---  -- -- -- - --  -- -- -- --  -- -- -- --  -- -- -- 

-- Part 15 - JOINS

-- A JOIN is a means for combining fields from two tables by using values common to each. 
-- The SQL JOIN clause is used to combine records from two or more tables in a database. 
-- There are six types of JOINS; the most frequent of which is the "INNER JOIN":
-- 1.	Right JOINs
--      A RIGHT JOIN retunes rows from the right table
--      Syntax:
--      SELECT col1, col2, .. FROM lefttable RIGHT JOIN righttable ON lefttablefield = righttablefield

--  Example: List the Names and titles of employees that have appointments
SELECT * FROM Employees;
SELECT * FROM Appointments;

SELECT FirstName, LastName, Title, Cost 
FROM Employees RIGHT JOIN Appointments 
ON Appointments.PrimaryEmployees_ID = Employees.ID;

-- 2.	Left JOINs
--      A LEFT JOIN retunes rows from the left table
--      Syntax:
--      SELECT col1, col2, .. FROM lefttable LEFT JOIN righttable ON lefttablefield = righttablefield

--  Example 1: List all patient names: showing OutOfPocketExpense, Plan Tier, and MaxOutOfPocket
SELECT * FROM Patients;
SELECT * FROM Plans;

SELECT FirstName, LastName, OutOfPocketToDate, Tier, MaxOutOfPocket 
FROM Patients LEFT JOIN Plans 
ON Patients.Plans_ID = Plans.ID;

-- Example 2: Modify the previous query to determine how much each patient has left to spend 
--            out of pocket and sort from largest remaining spend to smallest remaining 

SELECT FirstName, LastName, Tier, (MaxOutOfPocket - OutOfPocketToDate) AS Remaining
FROM Patients LEFT JOIN Plans 
ON Patients.Plans_ID = Plans.ID
ORDER BY Remaining DESC;


-- 3.   INNER JOINs
--      Also called an EQUIJOIN. The INNER JOIN creates a new result table by combining column 
--      values of two tables based on the join-predicate. 
--      The query compares each row of the first table with each row of the second table 
--      to find all pairs of rows which satisfy the join-predicate. 
--      When the join-predicate is satisfied, column values for each matched pair of rows 
--      of A and B are combined into a result row.
--      In MYSAL, an INNER JOIN is equivelent to JOIN
--      Syntax:
--      SELECT col1, col2, .. FROM lefttable INNER JOIN righttable ON lefttablefield = righttablefield
--  Example 1: Determine the OutofPocketToDate and Cost for each patient that has an 
--             appointment.
SELECT * FROM Patients;
SELECT * FROM Appointments;

SELECT FirstName, LastName, OutOfPocketToDate, Cost
FROM Patients INNER JOIN Appointments
ON Patients.ID = Appointments.Patients_ID
ORDER BY OutOfPocketToDate DESC;

--  Example 2: List all of the notes next to the patient name
--  Here, there are no common fields between Patients and Notes; thus a third (middle) table
--     should be used to create a bridge between the left and the right tables.
SELECT * FROM Patients;
SELECT * FROM Notes;
SELECT * FROM Appointments;

SELECT FirstName, LastName, Text 
FROM Patients INNER JOIN Appointments 
ON Patients.ID = Appointments.Patients_ID
INNER JOIN Notes ON Notes.Appointments_ID = Appointments.ID;


-- 4.	Full (outer) JOINs
--      A FULL JOIN combines the results from both right and left tables
--      Syntax:
--      SELECT col1, col2, .. FROM lefttable FULL JOIN righttable ON lefttablefield = righttablefield

-- 5.	Self JOINs
--      A SELF JOIN is used to join a table to itself as if the table were two tables, 
--      temporarily renaming at least one table in the SQL statement.
--      Syntax:
--      SELECT a.col1, b.col2, a.col3 .. FROM table a, table b WHERE a.tablefield condition b.tablefield 
--            "condition"as as a logical or mathematical operator ("=", "<", ">", ...)

-- 6.	Cartersian (Cross) JOINS
--      The CARTESIAN JOIN or CROSS JOIN returns the Cartesian product of the sets of records 
--      from the two or more joined tables. Thus, it equates to an inner join where the 
--      join-condition always evaluates to True or where the join-condition is absent from the 
--      statement.
--      Syntax:
--      SELECT col1, col2, .. FROM lefttable, righttable


-- Examples:

-- 1. List all employees and their department names
-- 2. Count the number of CURRENT employees in each medical center

USE dataMedical2;
SELECT MedicalCenters.ID, MedicalCenters.Nickname, MedicalCenters.FullName , count(*)
FROM Employees LEFT JOIN Departments 
ON Employees.PrimaryDepts_ID = Departments.ID
LEFT JOIN Buildings 
ON Buildings.ID = Departments.Buildings_ID
LEFT JOIN  MedicalCenters 
ON MedicalCenters.ID = Buildings.MedicalCenters_ID
WHERE Employees.Status = 'Current' 
GROUP BY MedicalCenters.ID;


--
--  
--  Additional topics in MySQL

-- 1. Ranking

SHOW TABLES FROM dataMedical2;

SELECT COUNT(*) FROM dataMedical2.appointments;
SELECT COUNT(*) FROM dataMedical2.buildings;
SELECT COUNT(*) FROM dataMedical2.departments;
SELECT COUNT(*) FROM dataMedical2.employees;
SELECT COUNT(*) FROM dataMedical2.medicalcenters;
SELECT COUNT(*) FROM dataMedical2.patients;
SELECT COUNT(*) FROM dataMedical2.prescriptions;
SELECT COUNT(*) FROM dataMedical2.plans;
SELECT COUNT(*) FROM dataMedical2.notes;

SELECT * FROM patients;
-- 
-- Example: – Rank the patients according to OutOfPocketToDate:
USE dataMedical2;
SELECT ID, OutOfPocketToDate, @rownum := @rownum + 1 AS rank
FROM dataMedical2.patients, (SELECT @rownum := 0) r
ORDER BY OutOfPocketToDate DESC;

-- Remove 0sand and NULLs from the display

SELECT ID, OutOfPocketToDate, @rownum := @rownum + 1 AS rank
FROM dataMedical2.patients, (SELECT @rownum := 0) r
WHERE OutOfPocketToDate > 0 AND OutOfPocketToDate IS NOT NULL
ORDER BY OutOfPocketToDate DESC;


-- Temprorary Tables:
-- Users can create temporary tables with the same name without conflict with other users
-- A temporary table will be deleted when client session ends, frees up memory
-- If temporary tables are created with the name of another table, that first table is hidden until end of session or temporary table is dropped

-- Syntax:
-- CREATE TEMPORARY TABLE table_name (
-- var1 VARCHAR NOT NULL,
-- var2 INT NOT NULL DEFAULT 0);

-- INSERT INTO table_name 
-- VALUES ('value1', value2);

-- SELECT * FROM table_name;

-- Example
SHOW TABLES FROM dataMedical2;
SELECT * FROM appointments LIMIT 10;

DROP TEMPORARY TABLE IF EXISTS ShortAppointments;
CREATE TEMPORARY TABLE ShortAppointments AS
SELECT Patients_ID, TimeLength, (Cost-Copay) 
FROM appointments
WHERE TimeLength <= 30;

SELECT * FROM ShortAppointments;


-- VIEWs:
-- Creating, Replacing, and Dropping VIEWs
-- A VIEW is a virtual table whose columns or rows can be selected from other existing tables:
-- Syntax:
-- CREATE VIEW view_name AS
-- SELECT column1, column2, ...
-- FROM table_name
-- WHERE condition; 

-- Then view it by: 
--   SELECT * FROM  view name

-- Example:

CREATE VIEW ShortAppointments AS
SELECT Patients_ID, TimeLength, (Cost-Copay) 
FROM appointments
WHERE TimeLength <= 30;

SELECT * FROM ShortAppointments;

-- Or,
CREATE OR REPLACE VIEW ShortAppointments AS
SELECT Patients_ID, TimeLength, (Cost-Copay) 
FROM appointments
WHERE TimeLength <= 30;

SELECT * FROM ShortAppointments;

--  ------------------------------------------------------------------
--  ------------------------------------------------------------------
--  ------------------------------------------------------------------
--  ------------------------------------------------------------------
